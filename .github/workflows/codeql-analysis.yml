name: "CodeQL Feature Extraction"

on:
  workflow_dispatch:

jobs:
  extract-features:
    # 不再直接在虚拟机上运行
    runs-on: ubuntu-latest
    
    # ========================== 最终核心修改点 ==========================
    # 指定我们的所有步骤都在一个特定的Docker容器内运行
    container:
      # 使用一个更旧、更稳定的Ubuntu 20.04镜像
      image: ubuntu:20.04
    # ==============================================================
    
    permissions:
      security-events: write
      actions: read
      contents: read

    steps:
    # 步骤1: 检出代码。Action会自动在容器内执行。
    - name: Checkout target source code
      uses: actions/checkout@v4
      with:
        ref: '50eed9b008e7eff012e788a8a328901f68373579'

    # 步骤2: 动态创建CodeQL查询文件
    - name: Create CodeQL Query File
      # 在容器内，我们需要先确保目录存在
      run: |
        mkdir -p ./.github/codeql-queries
        cat <<'EOF' > ./.github/codeql-queries/FeatureExtraction.ql
        /**
         * @name Extract Features for Cohesion Analysis
         * @description This query extracts all referenced symbols (functions, variables, types) for each source file.
         * @kind table
         */
        import cpp

        string getQualifiedName(Element e) {
          e.(Function).hasGlobalOrStdName() and result = e.(Function).getQualifiedName()
          or
          e.(Variable).hasGlobalOrStdName() and result = e.(Variable).getQualified_name()
          or
          result = e.(Type).getName()
        }

        from File f, Element ref, string featureType
        where
          (f.getExtension() = "cpp" or f.getExtension() = "h" or f.getExtension() = "hpp") and
          f.getRelativePath().matches("src/brpc/%") and
          (
            exists(Call c | c.getEnclosingFunction().getFile() = f and ref = c.getTarget() and featureType = "FunctionCall")
            or
            exists(VariableAccess va | va.getEnclosingFunction().getFile() = f and ref = va.getTarget() and featureType = "VariableAccess")
            or
            exists(TypeAccess ta | ta.getEnclosingFunction().getFile() = f and ref = ta.getType() and featureType = "TypeAccess")
          )
        select f.getRelativePath() as file, featureType, getQualifiedName(ref) as feature
        EOF

    # 步骤3: 初始化CodeQL
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: cpp
        queries: ./.github/codeql-queries/FeatureExtraction.ql

    # 步骤4: 在容器内安装所有依赖
    # Ubuntu 20.04的环境是干净的，我们需要安装所有东西
    - name: Install dependencies in container
      run: |
        # 设置DEBIAN_FRONTEND=noninteractive以避免交互式提示
        export DEBIAN_FRONTEND=noninteractive
        apt-get update
        # 安装git和ca-certificates，因为基础镜像可能没有
        apt-get install -y git ca-certificates
        apt-get install -y build-essential cmake libssl-dev protobuf-compiler libgflags-dev libleveldb-dev libprotobuf-dev libprotoc-dev

    # 步骤5: 编译项目
    - name: Build project
      run: |
        cmake .
        make -j2

    # 步骤6: 运行分析
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        output: ../results
        format: csv

    # 步骤7: 上传结果
    - name: Upload results as an artifact
      uses: actions/upload-artifact@v4
      with:
        name: codeql-feature-results
        path: ../results
